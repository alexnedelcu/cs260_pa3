GROUP ID: 5??

NAMES: Ioan Alexandru Nedelcu, David Werner, Sam

CONTENTS: 1, 5, 7

COMPLETE: 1, 5, 7

NOT COMPLETE: ?

UNFINISHED: ?

COMPILATION AND EXECUTION: 

P1
make build 				//compile test code
make test				//preform experiments in p1_timing
make demo				//demo functionality of dict with ints and chars
make clean				//clean compiled files

P2


P3


P4


P5
make build 				//compile test code
make test				//runs test code
make clean				//clean compiled files

P7
make build 				//compile test code
make test				//runs test code
make clean				//clean compiled files

P8


PROGRAM OUTPUT

  P1:
	make test:
	./p1_timing
		Inserting 50000 random integers into a hash table with 5 buckets
		Performing 10000 random inserts and tallying # of probes.
		Performing 10000 random inserts of existing items and tallying # of probes.
		Performing 10000 random deletes and tallying # of probes.
		Performing 10000 random deletes of items NOT in the dictionary and tallying
		# of probes.
		_____________TEST CONDITIONS____________
		N: 50000
		B: 5
		_________________RESULTS________________
		Average Insert of New Item :            10001.1
		Average Insert of Existing Item:        5072
		Average Successful Delete :             5033.46
		Average Unsuccessful Delete :           10000
	make demo:
		Preforms functionality tests on dictionaries containing ints and chars
		and outputs the operations and results to STDOUT.
  P2:
  P3:
  P4:
  P5:
	The test code performs Dijksta's algorithm on all nodes in the graph and
	prints out the information for each iteration as well as reconstructs the
	shortest paths.
	make test:
		Initial adjacency values:
		A[1,2]=4  A[1,3]=1  A[1,4]=5  A[1,5]=8  A[1,6]=10  A[3,2]=2  A[4,5]=2	A[5,6]=1
		
		Iteration       w       D[2]:P[2]       D[3]:P[3]       D[4]:P[4]		D[5]:P[5]	D[6]:P[6]
		init            -       4:1             1:1             5:1            8:1			10:1
		1               3       3:3             1:1             5:1            8:1			10:1
		2               2       3:3             1:1             5:1            8:1			10:1
		3               4       3:3             1:1             5:1            7:4			10:1
		4               5       3:3             1:1             5:1            7:4			8:5
		5               6       3:3             1:1             5:1            7:4			8:5
		Shortest paths from 1:
		1-3-2
		1-3
		1-4
		1-4-5
		1-4-5-6
	... The code will do the same for nodes 2-6, run it to see the results


  P7:
	The test code preforms Floyd's algorithm on the graph provided. It then
	reconstructs the shortest paths.
		Initial adjacency values:
		A[1,2]=4  A[1,3]=1  A[1,4]=5  A[1,5]=8  A[1,6]=10  A[3,2]=2  A[4,5]=2	A[5,6]=1
		
		D[1]:P[1]       D[2]:P[2]       D[3]:P[3]       D[4]:P[4]       D[5]:P[5]		D[6]:P[6]
		0:1             3:3             1:1             5:1             7:4				8:5
		-:-             0:2             -:-             -:-             -:-				-:-
		-:-             2:3             0:3             -:-             -:-				-:-
		-:-             -:-             -:-             0:4             2:4				3:5
		-:-             -:-             -:-             -:-             0:5				1:5
		-:-             -:-             -:-             -:-             -:-				0:6
		Shortest paths from 1:
		1-3-2
		1-3
		1-4
		1-4-5
		1-4-5-6
		Shortest paths from 2:
		Shortest paths from 3:
		3-2
		Shortest paths from 4:
		4-5
		4-5-6
		Shortest paths from 5:
		5-6
		Shortest paths from 6:

  P8:

P1:20) Dave
P2:20) Sam
P3:20) ?All
P4:20) ?All
P5:10) Dave
P6:30) Alex
P7:10) Dave
P8:10) Sam
P9:30) ? 
